--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -93,6 +93,7 @@ int ath_descdma_setup(struct ath_softc *
 #define ATH_TXBUF_RESERVE       5
 #define ATH_TXMAXTRY            13
 #define ATH_MAX_SW_RETRIES      30
+#define ATH_NUM_DATA_TX_QUEUES 4
 
 #define TID_TO_WME_AC(_tid)				\
 	((((_tid) == 0) || ((_tid) == 3)) ? IEEE80211_AC_BE :	\
@@ -126,7 +127,7 @@ int ath_descdma_setup(struct ath_softc *
 				    (IEEE80211_WEP_IVLEN +	\
 				     IEEE80211_WEP_KIDLEN +	\
 				     IEEE80211_WEP_CRCLEN))
-
+#define ATH_EMPOWER_DEFAULT_QUEUE 6
 /* return whether a bit at index _n in bitmap _bm is set
  * _sz is the size of the bitmap  */
 #define ATH_BA_ISSET(_bm, _n)  (((_n) < (WME_BA_BMP_SIZE)) &&		\
@@ -171,6 +172,8 @@ struct ath_txq {
 	u8 txq_tailidx;
 	int pending_frames;
 	struct sk_buff_head complete_q;
+
+	int current_slice; // Uninit if == -1
 };
 
 struct ath_frame_info {
@@ -263,7 +266,7 @@ struct ath_node {
 
 	bool sleeping;
 	bool no_ps_filter;
-	s64 airtime_deficit[IEEE80211_NUM_ACS];
+	s64 airtime_deficit[EMPOWER_NUM_SLICE];
 	u32 airtime_rx_start;
 
 #ifdef CONFIG_ATH9K_STATION_STATISTICS
@@ -283,7 +286,6 @@ struct ath_tx_control {
 	u8 paprd;
 };
 
-
 /**
  * @txq_map:  Index is mac80211 queue number.  This is
  *  not necessarily the same as the hardware queue number
@@ -297,7 +299,12 @@ struct ath_tx {
 	struct ath_descdma txdma;
 	struct ath_txq *txq_map[IEEE80211_NUM_ACS];
 	struct ath_txq *uapsdq;
-	u16 max_aggr_framelen[IEEE80211_NUM_ACS][4][32];
+	u16 max_aggr_framelen[EMPOWER_NUM_SLICE][4][32];
+
+	// This lock should be held when using (R/W) the slice_config below
+	spinlock_t slice_cfg_lock;	
+	// AC (== slice) configuration
+	struct ieee80211_tx_queue_params slice_config[EMPOWER_NUM_SLICE];
 };
 
 struct ath_rx_edma {
@@ -334,7 +341,7 @@ struct ath_acq {
 struct ath_chanctx {
 	struct cfg80211_chan_def chandef;
 	struct list_head vifs;
-	struct ath_acq acq[IEEE80211_NUM_ACS];
+	struct ath_acq acq[EMPOWER_NUM_SLICE];
 	int hw_queue_base;
 
 	/* do not dereference, use for comparison only */
@@ -439,7 +446,7 @@ ath_node_to_tid(struct ath_node *an, u8
 
 	BUG_ON(!vif);
 	if (sta)
-		txq = sta->txq[tidno % ARRAY_SIZE(sta->txq)];
+		txq = sta->txq[tidno];
 	else
 		txq = vif->txq;
 
@@ -499,7 +506,7 @@ void ath_roc_complete(struct ath_softc *
 struct ath_chanctx* ath_is_go_chanctx_present(struct ath_softc *sc);
 
 #else
-
+// Didn't even have to change this? Weird, but good for us. Simplifies some things.
 static inline bool ath9k_is_chanctx_enabled(void)
 {
 	return false;
@@ -619,6 +626,7 @@ void ath9k_release_buffered_frames(struc
 				   enum ieee80211_frame_release_type reason,
 				   bool more_data);
 void ath9k_wake_tx_queue(struct ieee80211_hw *hw, struct ieee80211_txq *queue);
+int ath9k_configure_queue_for_slice(struct ath_softc *sc, u16 slice, struct ath_txq *txq);
 
 /********/
 /* VIFs */
--- a/drivers/net/wireless/ath/ath9k/debug.c
+++ b/drivers/net/wireless/ath/ath9k/debug.c
@@ -639,13 +639,10 @@ static int read_file_queues(struct seq_f
 	struct ath_softc *sc = hw->priv;
 	struct ath_txq *txq;
 	int i;
-	static const char *qname[4] = {
-		"VO", "VI", "BE", "BK"
-	};
 
-	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-		txq = sc->tx.txq_map[i];
-		seq_printf(file, "(%s):  ", qname[i]);
+	for (i = 0; i < ATH_NUM_DATA_TX_QUEUES; i++) {
+		txq = sc->tx.txq[i];
+		seq_printf(file, "(%u):  ", i);
 		print_queue(sc, txq, file);
 	}
 
--- a/drivers/net/wireless/ath/ath9k/debug_sta.c
+++ b/drivers/net/wireless/ath/ath9k/debug_sta.c
@@ -52,10 +52,11 @@ static ssize_t read_file_node_aggr(struc
 			 "TID", "SEQ_START", "SEQ_NEXT", "BAW_SIZE",
 			 "BAW_HEAD", "BAW_TAIL", "BAR_IDX", "SCHED", "PAUSED");
 
-	for (tidno = 0; tidno < IEEE80211_NUM_TIDS; tidno++) {
+	for (tidno = 0; tidno < EMPOWER_NUM_SLICE; tidno++) {
 		tid = ath_node_to_tid(an, tidno);
-		txq = tid->txq;
-		ath_txq_lock(sc, txq);
+		// Locking the queue doesn't make sense here as it's just the default queue. Returned values are NOT guaranteed to be sane!
+		// txq = tid->txq;
+		// ath_txq_lock(sc, txq);
 		if (tid->active) {
 			len += scnprintf(buf + len, size - len,
 					 "%3d%11d%10d%10d%10d%10d%9d%6d\n",
@@ -68,7 +69,7 @@ static ssize_t read_file_node_aggr(struc
 					 tid->bar_index,
 					 !list_empty(&tid->list));
 		}
-		ath_txq_unlock(sc, txq);
+		// ath_txq_unlock(sc, txq);
 	}
 exit:
 	retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
--- a/drivers/net/wireless/ath/ath9k/htc.h
+++ b/drivers/net/wireless/ath/ath9k/htc.h
@@ -345,7 +345,7 @@ struct ath_tx_stats {
 	u32 skb_success_bytes;
 	u32 skb_failed;
 	u32 cab_queued;
-	u32 queue_stats[IEEE80211_NUM_ACS];
+	u32 queue_stats[ATH_NUM_DATA_TX_QUEUES];
 };
 
 struct ath_skbrx_stats {
--- a/drivers/net/wireless/ath/ath9k/init.c
+++ b/drivers/net/wireless/ath/ath9k/init.c
@@ -357,9 +357,17 @@ static int ath9k_init_queues(struct ath_
 
 	sc->tx.uapsdq = ath_txq_setup(sc, ATH9K_TX_QUEUE_UAPSD, 0);
 
+	// Forward everything we don't know about to a default TXq (shared with PS-Poll which is disabled)
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-		sc->tx.txq_map[i] = ath_txq_setup(sc, ATH9K_TX_QUEUE_DATA, i);
-		sc->tx.txq_map[i]->mac80211_qnum = i;
+		sc->tx.txq_map[i] = ATH_EMPOWER_DEFAULT_QUEUE;
+	}
+
+	// < 6
+	for (i = 0; i < ATH_NUM_DATA_TX_QUEUES; i++) {
+		// We don't use txq_map anymore, just force the qnum to 0
+		struct ath_txq *q = ath_txq_setup(sc, ATH9K_TX_QUEUE_DATA, i);
+		q->mac80211_qnum = 0;
+		q->current_slice = -1;
 	}
 	return 0;
 }
@@ -620,8 +628,10 @@ static int ath9k_init_softc(u16 devid, s
 
 	/* Will be cleared in ath9k_start() */
 	set_bit(ATH_OP_INVALID, &common->op_flags);
-	sc->airtime_flags = (AIRTIME_USE_TX | AIRTIME_USE_RX |
-			     AIRTIME_USE_NEW_QUEUES);
+	sc->airtime_flags = 0;
+	// Simplify - use old system, no airtime
+	// sc->airtime_flags = (AIRTIME_USE_TX | AIRTIME_USE_RX |
+	// 		     AIRTIME_USE_NEW_QUEUES);
 
 	sc->sc_ah = ah;
 	sc->dfs_detector = dfs_pattern_detector_init(common, NL80211_DFS_UNSET);
@@ -673,6 +683,7 @@ static int ath9k_init_softc(u16 devid, s
 	spin_lock_init(&sc->sc_serial_rw);
 	spin_lock_init(&sc->sc_pm_lock);
 	spin_lock_init(&sc->chan_lock);
+	spin_lock_init(&sc->tx.slice_cfg_lock);
 	mutex_init(&sc->mutex);
 	tasklet_init(&sc->intr_tq, ath9k_tasklet, (unsigned long)sc);
 	tasklet_init(&sc->bcon_tasklet, ath9k_beacon_tasklet,
@@ -698,6 +709,15 @@ static int ath9k_init_softc(u16 devid, s
 	if (ret)
 		goto err_hw;
 
+	for (int i = 0; i < EMPOWER_NUM_SLICE; i++) {
+		sc->tx.slice_config[i].txop = 0;
+		sc->tx.slice_config[i].cw_min = ATH9K_TXQ_USEDEFAULT;
+		sc->tx.slice_config[i].cw_max = ATH9K_TXQ_USEDEFAULT;
+		sc->tx.slice_config[i].aifs = ATH9K_TXQ_USEDEFAULT;
+		sc->tx.slice_config[i].uapsd = false;
+		sc->tx.slice_config[i].mu_edca = false;
+	}
+
 	ret = ath9k_init_queues(sc);
 	if (ret)
 		goto err_queues;
@@ -874,11 +894,13 @@ static void ath9k_set_hw_capab(struct at
 	ieee80211_hw_set(hw, SUPPORT_FAST_XMIT);
 	ieee80211_hw_set(hw, SUPPORTS_CLONED_SKBS);
 
-	if (ath9k_ps_enable)
-		ieee80211_hw_set(hw, SUPPORTS_PS);
+	// We don't want PS support
+	// if (ath9k_ps_enable)
+	// 	ieee80211_hw_set(hw, SUPPORTS_PS);
 
 	if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT) {
-		ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+		// Disable AMPDU in all cases, becuase TID is required in AGGR negotiation
+		// ieee80211_hw_set(hw, AMPDU_AGGREGATION);
 
 		if (AR_SREV_9280_20_OR_LATER(ah))
 			hw->radiotap_mcs_details |=
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -27,9 +27,9 @@ static bool ath_tx_complete_check(struct
 
 	if (sc->tx99_state)
 		return true;
-
-	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-		txq = sc->tx.txq_map[i];
+	// < 6
+	for (i = 0; i < ATH_NUM_DATA_TX_QUEUES; i++) {
+		txq = sc->tx.txq[i];
 
 		ath_txq_lock(sc, txq);
 		if (txq->axq_depth) {
--- a/drivers/net/wireless/ath/ath9k/mac.c
+++ b/drivers/net/wireless/ath/ath9k/mac.c
@@ -245,14 +245,15 @@ bool ath9k_hw_set_txq_props(struct ath_h
 	qi->tqi_burstTime = qinfo->tqi_burstTime;
 	qi->tqi_readyTime = qinfo->tqi_readyTime;
 
-	switch (qinfo->tqi_subtype) {
-	case ATH9K_WME_UPSD:
-		if (qi->tqi_type == ATH9K_TX_QUEUE_DATA)
-			qi->tqi_intFlags = ATH9K_TXQ_USE_LOCKOUT_BKOFF_DIS;
-		break;
-	default:
-		break;
-	}
+	// We don't allow for UAPSD
+	// switch (qinfo->tqi_subtype) {
+	// case ATH9K_WME_UPSD:
+	// 	if (qi->tqi_type == ATH9K_TX_QUEUE_DATA)
+	// 		qi->tqi_intFlags = ATH9K_TXQ_USE_LOCKOUT_BKOFF_DIS;
+	// 	break;
+	// default:
+	// 	break;
+	// }
 
 	return true;
 }
@@ -304,12 +305,12 @@ int ath9k_hw_setuptxqueue(struct ath_hw
 	case ATH9K_TX_QUEUE_CAB:
 		q = ATH9K_NUM_TX_QUEUES - 2;
 		break;
-	case ATH9K_TX_QUEUE_PSPOLL:
-		q = 1;
-		break;
 	case ATH9K_TX_QUEUE_UAPSD:
 		q = ATH9K_NUM_TX_QUEUES - 3;
 		break;
+	case ATH9K_TX_QUEUE_PSPOLL:
+		q = 4; // 6
+		break;
 	case ATH9K_TX_QUEUE_DATA:
 		q = qinfo->tqi_subtype;
 		break;
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -72,7 +72,7 @@ static bool ath9k_has_pending_frames(str
 	if (txq->mac80211_qnum >= 0) {
 		struct ath_acq *acq;
 
-		acq = &sc->cur_chan->acq[txq->mac80211_qnum];
+		acq = &sc->cur_chan->acq[txq->mac80211_qnum]; // TODO: What do 
 		if (!list_empty(&acq->acq_new) || !list_empty(&acq->acq_old))
 			pending = true;
 	}
@@ -801,7 +801,8 @@ static void ath9k_tx(struct ieee80211_hw
 	}
 
 	memset(&txctl, 0, sizeof(struct ath_tx_control));
-	txctl.txq = sc->tx.txq_map[skb_get_queue_mapping(skb)];
+	// txctl.txq = sc->tx.txq_map[skb_get_queue_mapping(skb)];
+	txctl.txq = sc->tx.txq_map[0]; // It doesn't matter - send to the default
 	txctl.sta = control->sta;
 
 	ath_dbg(common, XMIT, "transmitting packet, skb: %p\n", skb);
@@ -1232,11 +1233,11 @@ static void ath9k_assign_hw_queues(struc
 		return;
 
 	for (i = 0; i < IEEE80211_NUM_ACS; i++)
-		vif->hw_queue[i] = i;
+		vif->hw_queue[i] = 0;
 
 	if (vif->type == NL80211_IFTYPE_AP ||
 	    vif->type == NL80211_IFTYPE_MESH_POINT)
-		vif->cab_queue = hw->queues - 2;
+		vif->cab_queue = ATH9K_NUM_TX_QUEUES - 2
 	else
 		vif->cab_queue = IEEE80211_INVAL_HW_QUEUE;
 }
@@ -1632,28 +1633,54 @@ static int ath9k_conf_tx(struct ieee8021
 {
 	struct ath_softc *sc = hw->priv;
 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-	struct ath_txq *txq;
 	struct ath9k_tx_queue_info qi;
-	int ret = 0;
+	int ret, i = 0;
 
-	if (queue >= IEEE80211_NUM_ACS)
-		return 0;
+	spin_lock_bh(&sc->tx.slice_cfg_lock);
+	sc->tx.slice_config[queue].txop = params->txop;
+	sc->tx.slice_config[queue].cw_min = params->cw_min;
+	sc->tx.slice_config[queue].cw_max = params->cw_max;
+	sc->tx.slice_config[queue].aifs = params->aifs;
+	spin_unlock_bh(&sc->tx.slice_cfg_lock);
+
+	ath_dbg(common, CONFIG,
+		"Saving slice config [%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",
+		queue, params->aifs, params->cw_min,
+		params->cw_max, params->txop);
+
+	for (i = 0; i < ATH_NUM_DATA_TX_QUEUES; i++) {
+		ath_txq_lock(sc, &sc->tx.txq[i].axq_lock);
+		if (sc->tx.txq[i].current_slice == queue) {
+			ath9k_configure_queue_for_slice(sc, queue, sc->tx.txq[i])
+		}
+		ath_txq_unlock(sc, &sc->tx.txq[i].axq_lock);
+	}
 
-	txq = sc->tx.txq_map[queue];
+	return 0;
+}
+
+int ath9k_configure_queue_for_slice(struct ath_softc *sc, u16 slice, struct ath_txq *txq)
+{
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	struct ieee80211_tx_queue_params *params = &sc->tx.slice_config[slice];
+	struct ath9k_tx_queue_info qi;
+	int ret = 0;
 
 	ath9k_ps_wakeup(sc);
 	mutex_lock(&sc->mutex);
 
 	memset(&qi, 0, sizeof(struct ath9k_tx_queue_info));
 
+	spin_lock_bh(&sc->tx.slice_cfg_lock);	
 	qi.tqi_aifs = params->aifs;
 	qi.tqi_cwmin = params->cw_min;
 	qi.tqi_cwmax = params->cw_max;
 	qi.tqi_burstTime = params->txop * 32;
+	spin_unlock_bh(&sc->tx.slice_cfg_lock);
 
 	ath_dbg(common, CONFIG,
-		"Configure tx [queue/halq] [%d/%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",
-		queue, txq->axq_qnum, params->aifs, params->cw_min,
+		"Configure tx [slice/queue] [%d/%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",
+		slice, txq->axq_qnum, params->aifs, params->cw_min,
 		params->cw_max, params->txop);
 
 	ath_update_max_aggr_framelen(sc, queue, qi.tqi_burstTime);
--- a/drivers/net/wireless/ath/ath9k/xmit.c
+++ b/drivers/net/wireless/ath/ath9k/xmit.c
@@ -17,6 +17,7 @@
 #include <linux/dma-mapping.h>
 #include "ath9k.h"
 #include "ar9003_mac.h"
+#include "hw.h"
 
 #define BITS_PER_BYTE           8
 #define OFDM_PLCP_BITS          22
@@ -119,18 +120,19 @@ void __ath_tx_queue_tid(struct ath_softc
 	struct ath_chanctx *ctx = avp->chanctx;
 	struct ath_acq *acq;
 	struct list_head *tid_list;
-	u8 acno = TID_TO_WME_AC(tid->tidno);
+	// u8 acno = TID_TO_WME_AC(tid->tidno);
 
 	if (!ctx || !list_empty(&tid->list))
 		return;
 
 
-	acq = &ctx->acq[acno];
-	if ((sc->airtime_flags & AIRTIME_USE_NEW_QUEUES) &&
-	    tid->an->airtime_deficit[acno] > 0)
-		tid_list = &acq->acq_new;
-	else
-		tid_list = &acq->acq_old;
+	// acq = &ctx->acq[acno];
+	acq = &ctx->acq[tid->tidno];
+	// if ((sc->airtime_flags & AIRTIME_USE_NEW_QUEUES) &&
+	//     tid->an->airtime_deficit[acno] > 0)
+	// 	tid_list = &acq->acq_new;
+	// else
+	tid_list = &acq->acq_old;
 
 	list_add_tail(&tid->list, tid_list);
 }
@@ -144,7 +146,8 @@ void ath_tx_queue_tid(struct ath_softc *
 	if (!ctx || !list_empty(&tid->list))
 		return;
 
-	acq = &ctx->acq[TID_TO_WME_AC(tid->tidno)];
+	// acq = &ctx->acq[TID_TO_WME_AC(tid->tidno)];
+	acq = &ctx->acq[tid->tidno];
 	spin_lock_bh(&acq->lock);
 	__ath_tx_queue_tid(sc, tid);
 	spin_unlock_bh(&acq->lock);
@@ -204,7 +207,7 @@ static void ath_txq_skb_done(struct ath_
 	if (q < 0)
 		return;
 
-	txq = sc->tx.txq_map[q];
+	txq = sc->tx.txq[q];
 	if (WARN_ON(--txq->pending_frames < 0))
 		txq->pending_frames = 0;
 
@@ -213,7 +216,8 @@ static void ath_txq_skb_done(struct ath_
 static struct ath_atx_tid *
 ath_get_skb_tid(struct ath_softc *sc, struct ath_node *an, struct sk_buff *skb)
 {
-	u8 tidno = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+	// u8 tidno = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+	u8 tidno = skb->priority;
 	return ATH_AN_2_TID(an, tidno);
 }
 
@@ -806,7 +810,7 @@ static u32 ath_lookup_rate(struct ath_so
 	struct ieee80211_tx_rate *rates;
 	u32 max_4ms_framelen, frmlen;
 	u16 aggr_limit, bt_aggr_limit, legacy = 0;
-	int q = tid->txq->mac80211_qnum;
+	int q = tid->txq->current_slice;
 	int i;
 
 	skb = bf->bf_mpdu;
@@ -1618,7 +1622,7 @@ void ath_tx_aggr_sleep(struct ieee80211_
 
 	ath_dbg(common, XMIT, "%s called\n", __func__);
 
-	for (tidno = 0; tidno < IEEE80211_NUM_TIDS; tidno++) {
+	for (tidno = 0; tidno < EMPOWER_NUM_SLICE; tidno++) {
 		tid = ath_node_to_tid(an, tidno);
 		txq = tid->txq;
 
@@ -1647,7 +1651,7 @@ void ath_tx_aggr_wakeup(struct ath_softc
 
 	ath_dbg(common, XMIT, "%s called\n", __func__);
 
-	for (tidno = 0; tidno < IEEE80211_NUM_TIDS; tidno++) {
+	for (tidno = 0; tidno < EMPOWER_NUM_SLICE; tidno++) {
 		tid = ath_node_to_tid(an, tidno);
 		txq = tid->txq;
 
@@ -1732,16 +1736,17 @@ struct ath_txq *ath_txq_setup(struct ath
 {
 	struct ath_hw *ah = sc->sc_ah;
 	struct ath9k_tx_queue_info qi;
-	static const int subtype_txq_to_hwq[] = {
-		[IEEE80211_AC_BE] = ATH_TXQ_AC_BE,
-		[IEEE80211_AC_BK] = ATH_TXQ_AC_BK,
-		[IEEE80211_AC_VI] = ATH_TXQ_AC_VI,
-		[IEEE80211_AC_VO] = ATH_TXQ_AC_VO,
-	};
+	// static const int subtype_txq_to_hwq[] = {
+	// 	[IEEE80211_AC_BE] = ATH_TXQ_AC_BE,
+	// 	[IEEE80211_AC_BK] = ATH_TXQ_AC_BK,
+	// 	[IEEE80211_AC_VI] = ATH_TXQ_AC_VI,
+	// 	[IEEE80211_AC_VO] = ATH_TXQ_AC_VO,
+	// };
 	int axq_qnum, i;
 
 	memset(&qi, 0, sizeof(qi));
-	qi.tqi_subtype = subtype_txq_to_hwq[subtype];
+	// Subtype should just get returned to us from ath9k_hw_setuptxqueue
+	qi.tqi_subtype = subtype;
 	qi.tqi_aifs = ATH9K_TXQ_USEDEFAULT;
 	qi.tqi_cwmin = ATH9K_TXQ_USEDEFAULT;
 	qi.tqi_cwmax = ATH9K_TXQ_USEDEFAULT;
@@ -1947,10 +1952,108 @@ void ath_tx_cleanupq(struct ath_softc *s
 	sc->tx.txqsetup &= ~(1<<txq->axq_qnum);
 }
 
+int ath9k_reconf_txq(struct ieee80211_hw *hw,
+			 struct ieee80211_vif *vif, u16 queue,
+			 const struct ieee80211_tx_queue_params *params)
+{
+	struct ath_softc *sc = hw->priv;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	struct ath_txq *txq;
+	struct ath9k_tx_queue_info qi;
+	int ret = 0;
+
+	// if (queue >= IEEE80211_NUM_ACS)
+	// 	return 0;
+	// TODO: Actually rewrite this func
+	txq = sc->tx.txq_map[queue];
+
+	ath9k_ps_wakeup(sc);
+	mutex_lock(&sc->mutex);
+
+	memset(&qi, 0, sizeof(struct ath9k_tx_queue_info));
+
+	qi.tqi_aifs = params->aifs;
+	qi.tqi_cwmin = params->cw_min;
+	qi.tqi_cwmax = params->cw_max;
+	qi.tqi_burstTime = params->txop * 32;
+
+	ath_dbg(common, CONFIG,
+		"Configure tx [queue/halq] [%d/%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",
+		queue, txq->axq_qnum, params->aifs, params->cw_min,
+		params->cw_max, params->txop);
+
+	ath_update_max_aggr_framelen(sc, queue, qi.tqi_burstTime);
+	ret = ath_txq_update(sc, txq->axq_qnum, &qi);
+	if (ret)
+		ath_err(common, "TXQ Update failed\n");
+
+	mutex_unlock(&sc->mutex);
+	ath9k_ps_restore(sc);
+
+	return ret;
+}
+
+void ath_txq_schedule(struct ath_softc *sc, struct ath_txq *txq)
+{
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	struct ath_atx_tid *tid;
+	struct list_head *tid_list;
+	struct ath_acq *acq;
+	int ret;
+
+	if (test_bit(ATH_OP_HW_RESET, &common->op_flags))
+		return;
+
+	spin_lock_bh(&sc->chan_lock);
+	rcu_read_lock();
+
+	if (sc->cur_chan->stopped)
+		goto out;
+
+search:
+	tid_list = &acq->acq_old;
+	if (list_empty(tid_list))
+		goto out;
+
+	tid = list_first_entry(tid_list, struct ath_atx_tid, list);
+
+	// If the given TID has nothing to be sent
+	if (!ath_tid_has_buffered(tid)) {
+		spin_lock_bh(&acq->lock);
+		list_del_init(&tid->list);
+		spin_unlock_bh(&acq->lock);
+		goto search;
+	}
+
+	// Can't schedule anything
+	if (txq->current_slice != tid->tidno && !ath9k_has_pending_frames(sc, txq, false)) {
+		ret = ath9k_configure_queue_for_slice(sc, tid->tidno, txq);
+		if (!ret) 
+			goto out;
+
+		txq->current_slice = tid->tidno;
+	} else if (txq->current_slice != tid->tidno && ath9k_has_pending_frames(sc, txq, false)) {
+		// We can't TX and we also can't change the queue props
+		goto out;
+	}
+
+	if(ath_tx_sched_aggr(sc, txq, tid)) {
+		spin_lock_bh(&acq->lock);
+		// list_del_init(&tid->list);
+		list_move_tail(&tid->list, &acq->acq_old);
+		spin_unlock_bh(&acq->lock);
+	}
+
+out:
+	rcu_read_unlock();
+	spin_unlock_bh(&sc->chan_lock);
+
+}
+
 /* For each acq entry, for each tid, try to schedule packets
  * for transmit until ampdu_depth has reached min Q depth.
  */
-void ath_txq_schedule(struct ath_softc *sc, struct ath_txq *txq)
+void ath_txq_schedule_old(struct ath_softc *sc, struct ath_txq *txq)
 {
 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
 	struct ath_atx_tid *tid;
@@ -2023,8 +2126,8 @@ void ath_txq_schedule_all(struct ath_sof
 	struct ath_txq *txq;
 	int i;
 
-	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-		txq = sc->tx.txq_map[i];
+	for (i = 0; i < ATH_NUM_DATA_TX_QUEUES; i++) {
+		txq = sc->tx.txq[i];
 
 		spin_lock_bh(&txq->axq_lock);
 		ath_txq_schedule(sc, txq);
@@ -2372,10 +2475,11 @@ int ath_tx_start(struct ieee80211_hw *hw
 	}
 
 	ath_txq_lock(sc, txq);
-	if (txq == sc->tx.txq_map[q]) {
-		fi->txq = q;
-		++txq->pending_frames;
-	}
+	// This condition should never be false?
+	// if (txq == sc->tx.txq_map[q]) {
+	fi->txq = q;
+	++txq->pending_frames;
+	// }
 
 	bf = ath_tx_setup_buffer(sc, txq, tid, skb);
 	if (!bf) {
@@ -2865,10 +2969,10 @@ void ath_tx_node_init(struct ath_softc *
 	struct ath_atx_tid *tid;
 	int tidno, acno;
 
-	for (acno = 0; acno < IEEE80211_NUM_ACS; acno++)
-		an->airtime_deficit[acno] = ATH_AIRTIME_QUANTUM;
+	for (acno = 0; acno < EMPOWER_NUM_SLICE; acno++)
+		an->airtime_deficit[acno] = ATH_AIRTIME_QUANTUM; // This is disabled, we also don't really care about this
 
-	for (tidno = 0; tidno < IEEE80211_NUM_TIDS; tidno++) {
+	for (tidno = 0; tidno < EMPOWER_NUM_SLICE; tidno++) {
 		tid = ath_node_to_tid(an, tidno);
 		tid->an        = an;
 		tid->tidno     = tidno;
@@ -2880,8 +2984,7 @@ void ath_tx_node_init(struct ath_softc *
 		tid->has_queued  = false;
 		__skb_queue_head_init(&tid->retry_q);
 		INIT_LIST_HEAD(&tid->list);
-		acno = TID_TO_WME_AC(tidno);
-		tid->txq = sc->tx.txq_map[acno];
+		tid->txq = sc->tx.txq_map[0]; // Default queue, we don't care about this
 
 		if (!an->sta)
 			break; /* just one multicast ath_atx_tid */
@@ -2893,10 +2996,13 @@ void ath_tx_node_cleanup(struct ath_soft
 	struct ath_atx_tid *tid;
 	struct ath_txq *txq;
 	int tidno;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
 
-	rcu_read_lock();
 
-	for (tidno = 0; tidno < IEEE80211_NUM_TIDS; tidno++) {
+	rcu_read_lock();
+	ath_dbg(common, XMIT, "Draining node on the DEFAULT (!!) queue");
+	// Each TID will get drained into the DEFAULT queue
+	for (tidno = 0; tidno < EMPOWER_NUM_SLICE; tidno++) {
 		tid = ath_node_to_tid(an, tidno);
 		txq = tid->txq;
 
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -181,6 +181,7 @@ static inline u16 ieee80211_sn_sub(u16 s
 #define IEEE80211_MAX_MESH_ID_LEN	32
 
 #define IEEE80211_FIRST_TSPEC_TSID	8
+#define EMPOWER_NUM_SLICE 		64
 #define IEEE80211_NUM_TIDS		16
 
 /* number of user priorities 802.11 uses */
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -1822,8 +1822,8 @@ struct ieee80211_sta {
 	u16 max_amsdu_len;
 	bool support_p2p_ps;
 	u16 max_rc_amsdu_len;
-
-	struct ieee80211_txq *txq[IEEE80211_NUM_TIDS];
+	
+	struct ieee80211_txq *txq[EMPOWER_NUM_SLICE];
 
 	/* must be last */
 	u8 drv_priv[0] __aligned(sizeof(void *));
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -1247,6 +1247,7 @@ static struct txq_info *ieee80211_get_tx
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_txq *txq = NULL;
+	u8 tid;
 
 	if ((info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) ||
 	    (info->control.flags & IEEE80211_TX_CTRL_PS_RESPONSE))
@@ -1256,7 +1257,11 @@ static struct txq_info *ieee80211_get_tx
 		return NULL;
 
 	if (sta) {
-		u8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+		if (skb->priority > IEEE80211_NUM_TIDS) {
+			tid = skb->priority;
+		} else {
+			tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+		}
 
 		if (!sta->uploaded)
 			return NULL;
@@ -1833,8 +1838,9 @@ static bool ieee80211_tx(struct ieee8021
 	/* set up hw_queue value early */
 	if (!(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||
 	    !ieee80211_hw_check(&local->hw, QUEUE_CONTROL))
-		info->hw_queue =
-			sdata->vif.hw_queue[skb_get_queue_mapping(skb)];
+		// Because of changes below, let the driver handle everything
+		info->hw_queue = 0;
+			// sdata->vif.hw_queue[skb_get_queue_mapping(skb)];
 
 	if (invoke_tx_handlers_early(&tx))
 		return true;
@@ -3384,7 +3390,11 @@ static bool ieee80211_xmit_fast(struct i
 	info->control.flags = IEEE80211_TX_CTRL_FAST_XMIT;
 
 	if (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {
-		tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
+		if (tid >= IEEE80211_NUM_TIDS)
+			tid = 0;
+		else
+			tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;;
+		
 		*ieee80211_get_qos_ctl(hdr) = tid;
 	}
 
--- a/net/mac80211/wme.c
+++ b/net/mac80211/wme.c
@@ -236,10 +236,18 @@ void ieee80211_set_qos_hdr(struct ieee80
 {
 	struct ieee80211_hdr *hdr = (void *)skb->data;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	u8 tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
+	u8 tid;
 	u8 flags;
 	u8 *p;
 
+	// TID == AC == SLICE => Can't fit into 4 bits (we have 6)
+	// Default to 0 in QOS header
+	if (skb->priority > IEEE80211_NUM_TIDS) {
+		tid = 0;
+	} else {
+		tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
+	}
+
 	if (!ieee80211_is_data_qos(hdr->frame_control))
 		return;
 
