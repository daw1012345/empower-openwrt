--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -764,6 +764,9 @@ static void ath9k_tx(struct ieee80211_hw
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
 	unsigned long flags;
 
+	if (skb_get_queue_mapping(skb) >= EMP_NUM_USE_QUEUE)
+		printk(KERN_ERR "Invalid packet sent! Q=%u DNE.\n", skb_get_queue_mapping(skb));
+
 	if (sc->ps_enabled) {
 		/*
 		 * mac80211 does not set PM field for normal data frames, so we
@@ -819,6 +822,7 @@ static void ath9k_tx(struct ieee80211_hw
 	txctl.sta = control->sta;
 
 	ath_dbg(common, XMIT, "transmitting packet, skb: %p\n", skb);
+	// printk(KERN_ERR "TX packet: %u", skb_get_queue_mapping(skb));
 
 	if (ath_tx_start(hw, skb, &txctl) != 0) {
 		ath_dbg(common, XMIT, "TX failed\n");
@@ -1245,7 +1249,7 @@ static void ath9k_assign_hw_queues(struc
 	if (!ath9k_is_chanctx_enabled())
 		return;
 
-	for (i = 0; i < IEEE80211_NUM_ACS; i++)
+	for (i = 0; i < EMP_NUM_USE_QUEUE; i++)
 		vif->hw_queue[i] = i;
 
 	if (vif->type == NL80211_IFTYPE_AP ||
@@ -1650,7 +1654,7 @@ static int ath9k_conf_tx(struct ieee8021
 	struct ath9k_tx_queue_info qi;
 	int ret = 0;
 
-	if (queue >= IEEE80211_NUM_ACS)
+	if (queue >= EMP_NUM_USE_QUEUE)
 		return 0;
 
 	txq = sc->tx.txq_map[queue];
@@ -1665,8 +1669,7 @@ static int ath9k_conf_tx(struct ieee8021
 	qi.tqi_cwmax = params->cw_max;
 	qi.tqi_burstTime = params->txop * 32;
 
-	ath_dbg(common, CONFIG,
-		"Configure tx [queue/halq] [%d/%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",
+	printk(KERN_ERR "Configure tx [queue/halq] [%d/%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",
 		queue, txq->axq_qnum, params->aifs, params->cw_min,
 		params->cw_max, params->txop);
 
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -1246,9 +1246,11 @@ static u16 ieee80211_monitor_select_queu
 	struct ieee80211_hdr *hdr;
 	struct ieee80211_radiotap_header *rtap = (void *)skb->data;
 
-	if (local->hw.queues < IEEE80211_NUM_ACS)
+	if (skb->priority >= local->hw.queues)
 		return 0;
 
+	return skb->priority;
+
 	if (skb->len < 4 ||
 	    skb->len < le16_to_cpu(rtap->it_len) + 2 /* frame control */)
 		return 0; /* doesn't matter, frame will be dropped */
@@ -1849,7 +1851,7 @@ int ieee80211_if_add(struct ieee80211_lo
 			if_setup = ieee80211_if_setup;
 
 		if (local->hw.queues >= IEEE80211_NUM_ACS)
-			txqs = IEEE80211_NUM_ACS;
+			txqs = local->hw.queues;
 
 		ndev = alloc_netdev_mqs(size + txq_size,
 					name, name_assign_type,
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -2304,9 +2304,7 @@ static int parse_txq_params(struct nlatt
 	txq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);
 	txq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);
 
-	if (ac >= NL80211_NUM_ACS)
-		return -EINVAL;
-	txq_params->ac = array_index_nospec(ac, NL80211_NUM_ACS);
+	txq_params->ac = ac;
 	return 0;
 }
 
@@ -2570,9 +2568,10 @@ static int nl80211_set_wiphy(struct sk_b
 		if (!netdev)
 			return -EINVAL;
 
-		if (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&
-		    netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
-			return -EINVAL;
+		// We want to allow this in monitor mode as well
+		// if (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&
+		//     netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
+		// 	return -EINVAL;
 
 		if (!netif_running(netdev))
 			return -ENETDOWN;
--- a/net/mac80211/driver-ops.c
+++ b/net/mac80211/driver-ops.c
@@ -166,8 +166,8 @@ int drv_conf_tx(struct ieee80211_local *
 
 	might_sleep();
 
-	if (!check_sdata_in_driver(sdata))
-		return -EIO;
+	// if (!check_sdata_in_driver(sdata))
+	// 	return -EIO;
 
 	if (params->cw_min == 0 || params->cw_min > params->cw_max) {
 		/*
--- a/drivers/net/wireless/ath/ath9k/xmit.c
+++ b/drivers/net/wireless/ath/ath9k/xmit.c
@@ -1760,16 +1760,10 @@ struct ath_txq *ath_txq_setup(struct ath
 {
 	struct ath_hw *ah = sc->sc_ah;
 	struct ath9k_tx_queue_info qi;
-	static const int subtype_txq_to_hwq[] = {
-		[IEEE80211_AC_BE] = ATH_TXQ_AC_BE,
-		[IEEE80211_AC_BK] = ATH_TXQ_AC_BK,
-		[IEEE80211_AC_VI] = ATH_TXQ_AC_VI,
-		[IEEE80211_AC_VO] = ATH_TXQ_AC_VO,
-	};
 	int axq_qnum, i;
 
 	memset(&qi, 0, sizeof(qi));
-	qi.tqi_subtype = subtype_txq_to_hwq[subtype];
+	qi.tqi_subtype = subtype;
 	qi.tqi_aifs = ATH9K_TXQ_USEDEFAULT;
 	qi.tqi_cwmin = ATH9K_TXQ_USEDEFAULT;
 	qi.tqi_cwmax = ATH9K_TXQ_USEDEFAULT;
@@ -1986,6 +1980,9 @@ void ath_txq_schedule(struct ath_softc *
 	struct ath_acq *acq;
 	bool active = AIRTIME_ACTIVE(sc->airtime_flags);
 
+	printk_once(KERN_ERR "Ignoring request to schedule - queues should be empty!\n");
+	return;
+
 	if (txq->mac80211_qnum < 0)
 		return;
 
@@ -2051,6 +2048,9 @@ void ath_txq_schedule_all(struct ath_sof
 	struct ath_txq *txq;
 	int i;
 
+	printk_once(KERN_ERR "Ignoring request to schedule all - queues should be empty!\n");
+	return;
+
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		txq = sc->tx.txq_map[i];
 
@@ -2400,6 +2400,12 @@ int ath_tx_start(struct ieee80211_hw *hw
 	}
 
 	ath_txq_lock(sc, txq);
+
+	if (txq->pending_frames > 32) {
+		ieee80211_free_txskb(sc->hw, skb);
+		goto out;
+	}
+	
 	if (txq == sc->tx.txq_map[q]) {
 		fi->txq = q;
 		++txq->pending_frames;
--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -286,6 +286,8 @@ struct ath_tx_control {
 };
 
 
+#define EMP_NUM_USE_QUEUE  5
+
 /**
  * @txq_map:  Index is mac80211 queue number.  This is
  *  not necessarily the same as the hardware queue number
@@ -297,7 +299,7 @@ struct ath_tx {
 	struct list_head txbuf;
 	struct ath_txq txq[ATH9K_NUM_TX_QUEUES];
 	struct ath_descdma txdma;
-	struct ath_txq *txq_map[IEEE80211_NUM_ACS];
+	struct ath_txq *txq_map[EMP_NUM_USE_QUEUE];
 	struct ath_txq *uapsdq;
 	u16 max_aggr_framelen[IEEE80211_NUM_ACS][4][32];
 };
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -28,7 +28,7 @@ static bool ath_tx_complete_check(struct
 	if (sc->tx99_state)
 		return true;
 
-	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+	for (i = 0; i < EMP_NUM_USE_QUEUE; i++) {
 		txq = sc->tx.txq_map[i];
 
 		ath_txq_lock(sc, txq);
--- a/drivers/net/wireless/ath/ath9k/init.c
+++ b/drivers/net/wireless/ath/ath9k/init.c
@@ -411,9 +411,9 @@ static int ath9k_init_queues(struct ath_
 	sc->beacon.cabq = ath_txq_setup(sc, ATH9K_TX_QUEUE_CAB, 0);
 	ath_cabq_update(sc);
 
-	sc->tx.uapsdq = ath_txq_setup(sc, ATH9K_TX_QUEUE_UAPSD, 0);
+	// sc->tx.uapsdq = ath_txq_setup(sc, ATH9K_TX_QUEUE_UAPSD, 0);
 
-	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+	for (i = 0; i < EMP_NUM_USE_QUEUE; i++) {
 		sc->tx.txq_map[i] = ath_txq_setup(sc, ATH9K_TX_QUEUE_DATA, i);
 		sc->tx.txq_map[i]->mac80211_qnum = i;
 	}
@@ -986,7 +986,7 @@ static void ath9k_set_hw_capab(struct at
 	hw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
 	hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
 
-	hw->queues = 4;
+	hw->queues = EMP_NUM_USE_QUEUE;
 	hw->max_rates = 4;
 	hw->max_listen_interval = 10;
 	hw->max_rate_tries = 10;
